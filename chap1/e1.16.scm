;;
;; Exercise 1.16
;;
;; 求冪的三種算法(其中的第三種為我對題1.16給出的答案)

;; first-version 
;; 一般遞歸(線性遞歸)

(define expt1
  (lambda (b n)
    (if (= n 0) 1
        (* b (expt1 b (- n 1))))))

; 求值器內部 (這里用替換模型分析) 如: (expt1 2 10)
;
; (* 2 (expt1 2 (- 10 1)))
; (* 2 (* 2 (expt1 2 (- 9 1))))
; (* 2 (* 2 (* 2 (expt1 2 (- 8 1)))))
; (* 2 (* 2 (* 2 (* 2 (expt1 2 (- 7 1))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (expt1 2 (- 6 1)))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (expt1 2 (- 5 1))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (expt1 2 (- 4 1)))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (expt1 2 (- 3 1))))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (expt1 2 (- 2 1)))))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (expt1 2 (- 1 1))))))))))))
;; 以上每一行(表達式),都會生成一個"活動過程記錄"/"stack frame"
;; 當(- 1 1)時滿足(= n 0)，則返回1；又會有如下的返回情況
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 1))))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 2)))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 4))))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 8)))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 16))))))
; (* 2 (* 2 (* 2 (* 2 (* 2 32)))))
; (* 2 (* 2 (* 2 (* 2 64))))
; (* 2 (* 2 (* 2 128)))
; (* 2 (* 2 256))
; (* 2 512)
; 1024

;; second-version (尾遞歸)

(define tail-expt
    (lambda (b n)
        (let loop ((num b) (icount n))
            (if (= icount 1) num
                (loop (* num b) (- icount 1))))))

;; third-version (1.16答案)

(define (even? n)
    (= (remainder n 2) 0))

(define fast-exp
    (lambda (x n)
        (let loop ((sOdd 1) (sEven x) (iCount n))
            (cond 
                ((or (= iCount 1) (= iCount 0)) (* sOdd sEven))
                ((even? iCount) (loop sOdd (* sEven sEven) (/ iCount 2)))
                (else (loop (* sOdd sEven) sEven (- iCount 1)))))))
