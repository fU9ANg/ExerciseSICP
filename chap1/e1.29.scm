;;
;; Exercise 1.29
;;
(define (fn f a b n)
  
  (define (f-h) (/ (- b a) n))
  
  (define (term k)
    (cond 
      ((= k 0) (f a))
      ((= k n) (f (+ a (* k (f-h)))))
      ((= (remainder k 2) 0) (* 2 (f (+ a (* k (f-h))))))
      (else (* 4 (f (+ a (* k (f-h))))))))
  
  (exact->inexact (* (/ (f-h) 3) 
     (sum term 0 inc n)))) ; 關于sum的定義, 請看SICP第一章


; 通過此題, 可以看出sum中的term和next兩個形參; 不只可以接
; 受系統提供的過程, 也可以接受程序員自字義的過程(抽象).
;
; 比較: 使用"幸普森"的方法, 可以在 (fn cube 0 1 2) 中當n為
;       2時,就可以得到0.25(或1/4); 而在SICP中的例子中(使用
;       "一般求定積分") 方法, dx取0.00001時, 精確值為
;       0.24999999998662892
; 總結:
; 幸普森"的方法是非常有效率的, 很快就出來答案1/4; 而"一般
; 求定積分"方法, 當dx=0.000001時, 程序員是不能忍受的.
